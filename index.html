<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Quiz</title>
  <!-- Google Fonts: Poppins (√úberschriften) und Open Sans (Flie√ütext) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
  <!-- xlsx Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    :root {
      /* Farbverl√§ufe f√ºr die Kategorien */
      --easy-gradient: linear-gradient(135deg, #27ae60, #2ecc71);
      --medium-gradient: linear-gradient(135deg, #f1c40f, #f39c12);
      --hard-gradient: linear-gradient(135deg, #e74c3c, #c0392b);
      --special-gradient: linear-gradient(135deg, #8e44ad, #9b59b6);
      --death-gradient: linear-gradient(135deg, #000000, #4a0000);

      /* Farben f√ºr √úberschriften und Text */
      --heading-color: #ffffff;
      --body-color: #ecf0f1;
    }

    /* Bombastische √úberschrift mit 3D-Effekt, flammendem Gradienten, pulsierendem Glow und animierten Flammen */
    h1 {
      font-family: 'Poppins', sans-serif;
      font-size: 4.5em;
      text-align: center;
      text-transform: uppercase;
      margin: 40px 0;
      /* 3D-Text-Effekt √ºber mehrfachen Schatten */
      text-shadow: 
        0 0 10px #ff0000,
        2px 2px 0 #ff0000,
        4px 4px 0 #ff0000,
        6px 6px 0 #ff0000,
        8px 8px 0 #ff0000;
      animation: titleGlow 2s ease-in-out infinite alternate;
      background: linear-gradient(45deg, #ff0000, #ff6b6b, #ff0000);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      transform-style: preserve-3d;
      position: relative;
    }
    @keyframes titleGlow {
      0% { text-shadow: 0 0 10px #ff0000; }
      100% { text-shadow: 0 0 30px #ff0000, 0 0 20px #ff0000; }
    }
    /* Animierte Flammen unter der √úberschrift */
    h1::after {
      content: "";
      display: block;
      width: 200px;
      height: 30px;
      background: url('data:image/svg+xml,<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path fill="%23ff0000" d="M20,75 Q30,55 40,75 Q50,35 60,75 Q70,15 80,75 L50,100 L20,75"/></svg>');
      margin: 20px auto;
      animation: flame 0.8s ease-in-out infinite alternate;
    }
    @keyframes flame {
      from { transform: scale(1) rotate(-2deg); }
      to { transform: scale(1.2) rotate(2deg); }
    }

    /* Globale Basis */
    body {
      font-family: 'Open Sans', sans-serif;
      color: var(--body-color);
      background-color: #1a1a1a;
      margin: 20px;
      padding: 20px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Poppins', sans-serif;
      color: var(--heading-color);
    }

    /* Teams (modernisierte Buttons) */
    .teams {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 30px 0;
    }
    .team {
      padding: 20px;
      border-radius: 10px;
      background: rgba(44, 62, 80, 0.7);
      min-width: 200px;
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
    }
    /* Active-State mit Glow */
    .team.active {
      box-shadow: 0 0 15px #e67e22;
      transform: scale(1.05);
    }
    .points {
      font-size: 24px;
      color: #e67e22;
      margin: 10px 0;
    }

    /* Responsives Grid-Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin: 20px 0;
      padding: 20px;
    }

    .question-card {
      padding: 20px;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: all 0.3s ease;
      color: var(--heading-color);
      font-weight: 600;
      background: rgba(44, 62, 80, 0.5);
    }
    .easy { background: var(--easy-gradient); }
    .medium { background: var(--medium-gradient); }
    .hard { background: var(--hard-gradient); }
    .special { background: var(--special-gradient); }
    /* Die Death-Kategorie erh√§lt ein extra auff√§lliges Styling */
    .death { 
      background: var(--death-gradient); 
      position: relative;
      border: 3px solid #ff0000;
      animation: deathPulse 1.5s ease-in-out infinite;
      transform: rotate(-2deg);
      box-shadow: 
        0 0 30px #ff0000,
        0 0 60px #ff0000,
        0 0 90px #ff0000;
    }
    @keyframes deathPulse {
      0% { transform: rotate(-2deg) scale(1); }
      50% { transform: rotate(2deg) scale(1.05); }
      100% { transform: rotate(-2deg) scale(1); }
    }
    /* Totenkopf im Death-Fach */
    .death::before {
      content: "üíÄ";
      position: absolute;
      font-size: 4em;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.3;
      animation: skullFloat 3s ease-in-out infinite;
    }
    @keyframes skullFloat {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      50% { transform: translate(-50%, -55%) rotate(10deg); }
      100% { transform: translate(-50%, -50%) rotate(0deg); }
    }
    .death::after {
      content: "";
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border: 2px solid #ff0000;
      border-radius: 15px;
      animation: borderGlow 2s linear infinite;
    }
    @keyframes borderGlow {
      0% { box-shadow: 0 0 10px #ff0000; opacity: 1; }
      100% { box-shadow: 0 0 40px #ff0000; opacity: 0; }
    }

    .question-card.used {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }
    /* Leuchtender, pulsierender Rand f√ºr ausgew√§hlte Karten */
    .question-card.selected {
      z-index: 2;
      transform: scale(1.05);
      animation: glow 1.5s infinite;
    }
    @keyframes glow {
      0% { box-shadow: 0 0 5px white; }
      50% { box-shadow: 0 0 20px white; }
      100% { box-shadow: 0 0 5px white; }
    }

    .points-badge {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0,0,0,0.7);
      padding: 3px 8px;
      border-radius: 15px;
      font-size: 14px;
    }

    /* Modernisierte Buttons im Controls-Bereich (Glasdesign, Hover, Tiefenwirkung) */
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .controls button, .controls select {
      background: rgba(255,255,255,0.1);
      border: 2px solid #e67e22;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      font-size: 1.2em;
      padding: 20px 40px;
      margin: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
      color: var(--heading-color);
    }
    .controls button:hover, .controls select:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 45px rgba(230,126,34,0.5);
    }
    .controls button:before {
      content: "";
      position: absolute;
      top: 0;
      left: -75%;
      width: 50%;
      height: 100%;
      background: rgba(255,255,255,0.2);
      transform: skewX(-25deg);
      transition: all 0.5s ease;
    }
    .controls button:hover:before {
      left: 125%;
    }

    /* Inline-Fragencontainer mit Glassmorphism */
    .question-display {
      background: rgba(52,73,94, 0.5);
      padding: 30px;
      border-radius: 10px;
      margin: 30px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    /* √úberschriften im Fragebereich ‚Äì hervorgehoben mit Unterstrich */
    .question-display h3 {
      position: relative;
      margin-bottom: 10px;
      font-size: 1.6em;
    }
    .question-display h3:after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 50px;
      height: 3px;
      background: #e67e22;
    }

    .explanation {
      margin-top: 20px;
      padding: 15px;
      background: rgba(44, 62, 80, 0.7);
      border-radius: 8px;
      white-space: pre-wrap;
      line-height: 1.6;
    }

    .timer {
      font-size: 24px;
      color: #e74c3c;
      margin: 15px 0;
    }

    .timer-controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* Button f√ºr Excel-Template-Download */
    .download-template-btn {
      background: rgba(255,255,255,0.1);
      border: 2px solid #27ae60;
      font-size: 1.2em;
      padding: 15px 30px;
      margin: 15px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.3s ease;
      color: #ecf0f1;
    }
    .download-template-btn:hover {
      transform: translateY(-3px);
    }
  </style>
</head>
<body>
  <h1>Quiz</h1>

  <!-- Excel-Import UI ‚Äì ausschlie√ülich sichtbar, bis ein Report hochgeladen wurde -->
  <input type="file" id="excelUpload" accept=".xlsx" hidden>
  <button onclick="handleExcelUpload()">Excel Import üóÇÔ∏è</button>
  <!-- Alles zur√ºcksetzen Button -->
  <button onclick="resetAll()">Alles zur√ºcksetzen</button>
  
  <!-- Neuer Button: Excel-Template herunterladen -->
  <button class="download-template-btn" onclick="downloadExcelTemplate()">
    Excel-Template herunterladen
  </button>

  <!-- Spielsteuerung: erst nach Excel-Import wird hier die Teamauswahl angezeigt -->
  <div class="controls" id="controls" style="display: none;">
    <label for="teamCount" style="color: var(--heading-color); font-size: 1.2em;">Anzahl der Teams:</label>
    <select id="teamCount">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
    </select>
    <button onclick="initGame()">Spiel starten</button>
  </div>

  <div class="teams" id="teamsContainer"></div>

  <div class="grid" id="questionsGrid">
    <p style="text-align:center; color:#ccc;">Noch keine Fragen importiert. Bitte laden Sie einen Excel Report hoch.</p>
  </div>

  <!-- Nicht genutzt ‚Äì Fragen werden inline angezeigt -->
  <div class="question-display" id="questionDisplay" style="display:none">
    W√§hlen Sie eine Frage aus der Quiz-Wand!
  </div>

  <script>
    /*******************************
     * Hilfsfunktion: Ersten Buchstaben gro√ü
     *******************************/
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }

    /*******************************
     * Excel-Import Modul
     *******************************/
    // Permanenter Event Listener f√ºr den File-Input
    document.getElementById("excelUpload").addEventListener("change", async (e) => {
      try {
        const file = e.target.files[0];
        if (!file) return;
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        // Array of Arrays; leere Zellen werden als "" zur√ºckgegeben
        const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });

        // Initialisiere leeres Import-Objekt
        const importedQuestions = { easy: [], medium: [], hard: [], death: [] };
        const categories = ["easy", "medium", "hard", "death"];
        // Neues Regex, das den fixen Teil, die Zahl und alle zus√§tzlichen Worte erfasst
        const headerRegex = /^(easy|medium|hard|death)\s*(\d+)(.*)$/i;

        // F√ºr jede Kategorie-Spalte (A=0, B=1, etc.)
        for (let colIndex = 0; colIndex < categories.length; colIndex++) {
          // Durchlaufe alle Zeilen
          for (let row = 0; row < json.length; row++) {
            const cell = json[row][colIndex];
            if (typeof cell === "string" && cell.trim()) {
              const match = cell.match(headerRegex);
              if (match) {
                // Extrahiere:
                // match[1]: Kategorie (easy, medium, hard, death)
                // match[2]: Frage-Nummer
                // match[3]: Zus√§tzlicher Text (z. B. "Test 1")
                const categoryFromCell = match[1].toLowerCase();
                const questionNumber = match[2];
                const extraText = match[3].trim();
                const displayHeader = `${capitalize(categoryFromCell)} Frage ${questionNumber}${extraText ? " " + extraText : ""}`;

                // Frage und Erkl√§rung aus den n√§chsten beiden Zeilen
                const questionText = json[row + 1] ? json[row + 1][colIndex] : "";
                const explanationText = json[row + 2] ? json[row + 2][colIndex] : "";
                if (!questionText.trim() || !explanationText.trim()) {
                  showToast(`Fehler: Fehlende Frage oder Erkl√§rung bei "${cell}"`);
                  continue;
                }
                // Punkte je Kategorie
                let points;
                switch (categories[colIndex]) {
                  case "easy": points = 200; break;
                  case "medium": points = 400; break;
                  case "hard": points = 600; break;
                  case "death": points = 1000; break;
                  default: points = 0;
                }
                const newQuestion = {
                  header: displayHeader,  // Neuer Header-Wert
                  question: questionText,
                  explanation: explanationText,
                  points: points,
                  used: false,
                  selected: false,
                  attempts: 0,
                  special: (categories[colIndex] === "death")
                };
                importedQuestions[categories[colIndex]].push(newQuestion);
                // √úberspringe den Block (Header, Frage, Erkl√§rung, Leerzeile)
                row += 3;
              }
            }
          }
        }

        // Ersetze den globalen Fragenpool mit den importierten Fragen
        questions.easy = importedQuestions.easy;
        questions.medium = importedQuestions.medium;
        questions.hard = importedQuestions.hard;
        questions.death = importedQuestions.death;
        
        createQuestionGrid();
        // Nach Import: Zeige die Spielsteuerung (Team-Auswahl) an
        document.getElementById("controls").style.display = "flex";
        showToast("Excel Import erfolgreich!");
      } catch (err) {
        console.error(err);
        showToast("Fehler beim Importieren der Excel-Datei.");
      }
    });

    // Funktion, die den Dateiauswahl-Dialog √∂ffnet
    async function handleExcelUpload() {
      const fileInput = document.getElementById("excelUpload");
      // Wichtig: Wert zur√ºcksetzen, damit der Change-Event ausgel√∂st wird, selbst wenn dieselbe Datei erneut gew√§hlt wird
      fileInput.value = '';
      fileInput.click();
    }

    function showToast(message) {
      const toast = document.createElement("div");
      toast.textContent = message;
      toast.style.position = "fixed";
      toast.style.bottom = "20px";
      toast.style.left = "50%";
      toast.style.transform = "translateX(-50%)";
      toast.style.background = "rgba(0,0,0,0.7)";
      toast.style.color = "#ecf0f1";
      toast.style.padding = "10px 20px";
      toast.style.borderRadius = "5px";
      toast.style.zIndex = "1000";
      document.body.appendChild(toast);
      setTimeout(() => { toast.remove(); }, 3000);
    }

    /*******************************
     * Quiz-Logik
     *******************************/
    // Globaler Fragenpool ‚Äì zun√§chst leer, bis ein Excel-Report importiert wurde
    const questions = {
      easy: [],
      medium: [],
      hard: [],
      death: []
    };

    let teams = [];
    let currentTeam = 0;
    let selectedQuestion = null;
    let countdownInterval = null;
    let timeLeft = 0;
    let timerRunning = false;
    // Referenz auf das aktuell ge√∂ffnete Karten-DOM-Element
    let openInlineQuestionCard = null;

    // Wird √ºber den Start-Button der Team-Auswahl aufgerufen
    function initGame() {
      const teamCount = parseInt(document.getElementById("teamCount").value, 10);
      startGame(teamCount);
      // Optional: Blende die Team-Auswahl aus, wenn gew√ºnscht.
      document.getElementById("controls").style.display = "none";
    }

    function startGame(teamCount) {
      teams = Array.from({ length: teamCount }, (_, i) => ({
        name: `Team ${i + 1}`,
        points: 0
      }));
      
      Object.values(questions).forEach(category => {
        category.forEach(q => {
          q.used = false;
          q.selected = false;
          q.attempts = 0;
        });
      });

      currentTeam = 0;
      clearInterval(countdownInterval);
      timerRunning = false;
      renderTeams();
      createQuestionGrid();
    }

    function renderTeams() {
      const container = document.getElementById("teamsContainer");
      container.innerHTML = teams.map((team, index) => `
        <div class="team ${index === currentTeam ? 'active' : ''}">
          <h3>${team.name}</h3>
          <div class="points">${team.points} Punkte</div>
        </div>
      `).join('');
    }

    function createQuestionGrid() {
      const grid = document.getElementById("questionsGrid");
      grid.innerHTML = "";
      
      let hasQuestions = false;
      Object.entries(questions).forEach(([difficulty, items]) => {
        if (items.length) hasQuestions = true;
        items.forEach((q, index) => {
          const card = document.createElement("div");
          card.className = `question-card ${difficulty} ${q.used ? 'used' : ''} ${q.selected ? 'selected' : ''}`;
          card.innerHTML = `
            <div class="points-badge">${q.attempts > 0 ? Math.floor(q.points / 2) : q.points}</div>
            ${q.special ? 'üíÄ' : ''} ${q.header ? q.header : `${difficulty.toUpperCase()}-Frage ${index + 1}`}
          `;
          
          if (!q.used) {
            card.onclick = () => {
              toggleInlineQuestion(card, q, difficulty, index);
            };
          }
          grid.appendChild(card);
        });
      });
      if (!hasQuestions) {
        grid.innerHTML = `<p style="text-align:center; color:#ccc;">Noch keine Fragen importiert. Bitte laden Sie einen Excel Report hoch.</p>`;
      }
    }

    function toggleInlineQuestion(card, question, difficulty, index) {
      // Falls dieselbe Karte bereits ausgew√§hlt war: Schlie√üe sie
      if (openInlineQuestionCard === card) {
        closeInlineQuestion();
        question.selected = false;
        return;
      }
      
      // Falls bereits eine andere Karte ge√∂ffnet ist, schlie√üe diese
      if (openInlineQuestionCard && openInlineQuestionCard !== card) {
        closeInlineQuestion();
      }
      
      // Markiere die aktuelle Frage als ausgew√§hlt
      selectedQuestion = question;
      question.selected = true;
      card.classList.add("selected");
      openInlineQuestionCard = card;
      
      let seconds = 60;
      if (difficulty === 'medium') seconds = 120;
      if (difficulty === 'hard') seconds = 180;
      if (difficulty === 'death') seconds = 75;
      timeLeft = seconds;
      timerRunning = false;
      
      const inlineContainer = document.createElement("div");
      inlineContainer.id = "inlineQuestionDisplay";
      inlineContainer.className = "question-display";
      inlineContainer.style.gridColumn = "1 / -1";
      
      // Erstelle den HTML-Inhalt
      let displayHTML = `
        <h3>${question.header ? question.header : `${difficulty.toUpperCase()}-Frage ${index + 1}`} (${question.attempts > 0 ? Math.floor(question.points / 2) : question.points} Punkte)</h3>
        <p>${question.question}</p>
        <div class="timer" id="timerDisplay">Timer: ${formatTime(seconds)}</div>
        <div class="timer-controls">
          <button id="timerControl">Timer starten</button>
          <button id="resetTimer">Timer zur√ºcksetzen</button>
        </div>
        <button data-action="showAnswer">Antwort anzeigen</button>
        <div class="explanation" style="display:none">
          ${question.explanation}
        </div>
        <div class="judgementButtons" style="display:none; margin-top:20px">
          <button data-answer="true">Richtig ‚úÖ</button>
          <button data-answer="false">Falsch ‚ùå</button>
        </div>
      `;
      
      inlineContainer.innerHTML = displayHTML;
      card.parentNode.insertBefore(inlineContainer, card.nextSibling);
      
      // Timer-Steuerung
      inlineContainer.querySelector("#timerControl").addEventListener("click", () => {
        toggleTimer();
      });
      inlineContainer.querySelector("#resetTimer").addEventListener("click", () => {
        resetTimer();
      });
      
      // Antwort anzeigen: Beim Klick werden Erkl√§rung und Buttons sichtbar
      inlineContainer.querySelector("button[data-action='showAnswer']").addEventListener("click", function() {
        inlineContainer.querySelector(".explanation").style.display = 'block';
        inlineContainer.querySelector(".judgementButtons").style.display = 'block';
      });
      
      // Event-Listener f√ºr die Antwort-Buttons
      inlineContainer.querySelector("button[data-answer='true']").addEventListener("click", function() {
        handleAnswer(true);
      });
      inlineContainer.querySelector("button[data-answer='false']").addEventListener("click", function() {
        handleAnswer(false);
      });
    }

    function resetTimer() {
      const difficulty = Object.entries(questions).find(([_, cat]) => 
        cat.includes(selectedQuestion)
      )[0];
      
      if (difficulty === 'easy') timeLeft = 60;
      else if (difficulty === 'medium') timeLeft = 120;
      else if (difficulty === 'hard') timeLeft = 180;
      else timeLeft = 75;
      
      updateTimerDisplay();
    }

    function toggleTimer() {
      const timerButton = document.getElementById('timerControl');
      if (!timerRunning) {
        timerRunning = true;
        timerButton.textContent = 'Timer stoppen';
        startTimer(timeLeft);
      } else {
        timerRunning = false;
        timerButton.textContent = 'Timer fortsetzen';
        clearInterval(countdownInterval);
      }
    }

    function startTimer(seconds) {
      timeLeft = seconds;
      updateTimerDisplay();
      
      countdownInterval = setInterval(() => {
        if (timerRunning) {
          timeLeft--;
          updateTimerDisplay();
          
          if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            if (selectedQuestion && !selectedQuestion.joker) {
              handleAnswer(false);
            }
          }
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const timerDisplay = document.getElementById('timerDisplay');
      if (timerDisplay) {
        timerDisplay.textContent = `Timer: ${formatTime(timeLeft)}`;
      }
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Angepasste handleAnswer-Funktion:
    function handleAnswer(isCorrect) {
      // Fehlerpr√ºfung: Falls kein Frageobjekt ausgew√§hlt ist, abbrechen.
      if (!selectedQuestion) {
        console.error("Kein Frageobjekt ausgew√§hlt!");
        return;
      }
      
      // Lokale Referenz, damit sp√§tere √Ñnderungen an selectedQuestion keinen Fehler verursachen.
      const currentQuestion = selectedQuestion;
      
      // Deaktiviere alle Antwort-Buttons, um Mehrfachklicks zu verhindern.
      const inlineContainer = document.getElementById("inlineQuestionDisplay");
      if (inlineContainer) {
        inlineContainer.querySelectorAll("button[data-answer]").forEach(btn => btn.disabled = true);
      }
      
      clearInterval(countdownInterval);
      timerRunning = false;
      
      if (isCorrect) {
        const points = currentQuestion.attempts > 0 
          ? Math.floor(currentQuestion.points / 2)
          : currentQuestion.points;
        teams[currentTeam].points += points;
        currentQuestion.used = true;
      } else {
        currentQuestion.attempts++;
        if (currentQuestion.attempts >= 2) {
          currentQuestion.used = true;
        }
      }
      
      // Setze den selected-Zustand zur√ºck, damit die Kachel nicht mehr leuchtet.
      currentQuestion.selected = false;
      
      // Entferne den Inline-Fragencontainer
      closeInlineQuestion();
      
      // Wechsle zum n√§chsten Team
      currentTeam = (currentTeam + 1) % teams.length;
      
      renderTeams();
      createQuestionGrid();
      
      document.getElementById("questionDisplay").innerHTML = `
        <p>${isCorrect ? '‚úÖ Richtige Antwort!' : '‚ùå Falsche Antwort oder Zeit abgelaufen!'}<br>
        N√§chste Runde: ${teams[currentTeam].name}</p>
      `;
      
      checkGameEnd();
    }

    // Entfernt den Inline-Fragencontainer, entfernt die "selected"-Klasse und setzt selectedQuestion zur√ºck
    function closeInlineQuestion() {
      const inline = document.getElementById("inlineQuestionDisplay");
      if (inline) inline.remove();
      if (openInlineQuestionCard) {
        openInlineQuestionCard.classList.remove("selected");
      }
      openInlineQuestionCard = null;
      selectedQuestion = null;
    }

    function nextRound() {
      if (selectedQuestion) {
        selectedQuestion.selected = false;
      }
      closeInlineQuestion();
      currentTeam = (currentTeam + 1) % teams.length;
      renderTeams();
      createQuestionGrid();
      document.getElementById("questionDisplay").innerHTML = `
        <p>N√§chste Runde: ${teams[currentTeam].name}</p>
      `;
      checkGameEnd();
    }

    function checkGameEnd() {
      const allUsed = Object.values(questions).every(category => 
        category.every(q => q.used)
      );
      
      if (allUsed) {
        const winner = teams.reduce((prev, current) => 
          (prev.points > current.points) ? prev : current);
          
        alert(`üèÜ Spielende! Gewinner ist ${winner.name} mit ${winner.points} Punkten!`);
        startGame(teams.length);
      }
    }

    // Funktion zum kompletten Zur√ºcksetzen (Reset)
    function resetAll() {
      // Reset global state
      teams = [];
      currentTeam = 0;
      selectedQuestion = null;
      clearInterval(countdownInterval);
      timerRunning = false;
      openInlineQuestionCard = null;
      
      // Clear UI elements
      document.getElementById("teamsContainer").innerHTML = "";
      document.getElementById("questionsGrid").innerHTML = 
        `<p style="text-align:center; color:#ccc;">Noch keine Fragen importiert. Bitte laden Sie einen Excel Report hoch.</p>`;
      document.getElementById("questionDisplay").style.display = "none";
      document.getElementById("controls").style.display = "none";
      
      // Clear questions arrays
      questions.easy = [];
      questions.medium = [];
      questions.hard = [];
      questions.death = [];
      
      // Reset file input to allow re-uploading the same file
      document.getElementById("excelUpload").value = '';
      
      showToast("Alles zur√ºckgesetzt!");
    }
  </script>

  <!-- Binde die externe Datei f√ºr den Template-Download ein -->
  <script src="download-template.js"></script>
</body>
</html>
