<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Quiz</title>
  <!-- Google Fonts: Poppins (√úberschriften) und Open Sans (Flie√ütext) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
  <!-- xlsx Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    :root {
      /* Farbverl√§ufe f√ºr die Kategorien */
      --easy-gradient: linear-gradient(135deg, #27ae60, #2ecc71);
      --medium-gradient: linear-gradient(135deg, #f1c40f, #f39c12);
      --hard-gradient: linear-gradient(135deg, #e74c3c, #c0392b);
      --special-gradient: linear-gradient(135deg, #8e44ad, #9b59b6);
      --death-gradient: linear-gradient(135deg, #000000, #4a0000);

      /* Farben f√ºr √úberschriften und Text */
      --heading-color: #ffffff;
      --body-color: #ecf0f1;
    }

    /* Bombastische √úberschrift mit 3D-Effekt, flammendem Gradienten, pulsierendem Glow und animierten Flammen */
    h1 {
      font-family: 'Poppins', sans-serif;
      font-size: 4.5em;
      text-align: center;
      text-transform: uppercase;
      margin: 40px 0;
      /* 3D-Text-Effekt √ºber mehrfachen Schatten */
      text-shadow: 
        0 0 10px #ff0000,
        2px 2px 0 #ff0000,
        4px 4px 0 #ff0000,
        6px 6px 0 #ff0000,
        8px 8px 0 #ff0000;
      animation: titleGlow 2s ease-in-out infinite alternate;
      background: linear-gradient(45deg, #ff0000, #ff6b6b, #ff0000);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      transform-style: preserve-3d;
      position: relative;
    }
    @keyframes titleGlow {
      0% { text-shadow: 0 0 10px #ff0000; }
      100% { text-shadow: 0 0 30px #ff0000, 0 0 20px #ff0000; }
    }
    /* Animierte Flammen unter der √úberschrift */
    h1::after {
      content: "";
      display: block;
      width: 200px;
      height: 30px;
      background: url('data:image/svg+xml,<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path fill="%23ff0000" d="M20,75 Q30,55 40,75 Q50,35 60,75 Q70,15 80,75 L50,100 L20,75"/></svg>');
      margin: 20px auto;
      animation: flame 0.8s ease-in-out infinite alternate;
    }
    @keyframes flame {
      from { transform: scale(1) rotate(-2deg); }
      to { transform: scale(1.2) rotate(2deg); }
    }

    /* Globale Basis */
    body {
      font-family: 'Open Sans', sans-serif;
      color: var(--body-color);
      background-color: #1a1a1a;
      margin: 20px;
      padding: 20px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Poppins', sans-serif;
      color: var(--heading-color);
    }

    /* Teams (modernisierte Buttons) */
    .teams {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 30px 0;
    }
    .team {
      padding: 20px;
      border-radius: 10px;
      background: rgba(44, 62, 80, 0.7);
      min-width: 200px;
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
    }
    /* Active-State mit Glow */
    .team.active {
      box-shadow: 0 0 15px #e67e22;
      transform: scale(1.05);
    }
    .points {
      font-size: 24px;
      color: #e67e22;
      margin: 10px 0;
    }

    /* Responsives Grid-Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin: 20px 0;
      padding: 20px;
    }

    .question-card {
      padding: 20px;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: all 0.3s ease;
      color: var(--heading-color);
      font-weight: 600;
      background: rgba(44, 62, 80, 0.5);
    }
    .easy { background: var(--easy-gradient); }
    .medium { background: var(--medium-gradient); }
    .hard { background: var(--hard-gradient); }
    .special { background: var(--special-gradient); }
    /* Die Death-Kategorie erh√§lt ein extra auff√§lliges Styling */
    .death { 
      background: var(--death-gradient); 
      position: relative;
      border: 3px solid #ff0000;
      animation: deathPulse 1.5s ease-in-out infinite;
      transform: rotate(-2deg);
      box-shadow: 
        0 0 30px #ff0000,
        0 0 60px #ff0000,
        0 0 90px #ff0000;
    }
    @keyframes deathPulse {
      0% { transform: rotate(-2deg) scale(1); }
      50% { transform: rotate(2deg) scale(1.05); }
      100% { transform: rotate(-2deg) scale(1); }
    }
    /* Totenkopf im Death-Fach */
    .death::before {
      content: "üíÄ";
      position: absolute;
      font-size: 4em;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.3;
      animation: skullFloat 3s ease-in-out infinite;
    }
    @keyframes skullFloat {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      50% { transform: translate(-50%, -55%) rotate(10deg); }
      100% { transform: translate(-50%, -50%) rotate(0deg); }
    }
    .death::after {
      content: "";
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border: 2px solid #ff0000;
      border-radius: 15px;
      animation: borderGlow 2s linear infinite;
    }
    @keyframes borderGlow {
      0% { box-shadow: 0 0 10px #ff0000; opacity: 1; }
      100% { box-shadow: 0 0 40px #ff0000; opacity: 0; }
    }

    .question-card.used {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }
    /* Leuchtender, pulsierender Rand f√ºr ausgew√§hlte Karten */
    .question-card.selected {
      z-index: 2;
      transform: scale(1.05);
      animation: glow 1.5s infinite;
    }
    @keyframes glow {
      0% { box-shadow: 0 0 5px white; }
      50% { box-shadow: 0 0 20px white; }
      100% { box-shadow: 0 0 5px white; }
    }

    .points-badge {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0,0,0,0.7);
      padding: 3px 8px;
      border-radius: 15px;
      font-size: 14px;
    }

    /* Modernisierte Team-Buttons im Controls-Bereich (Glasdesign, Hover, Tiefenwirkung) */
    .controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }

    .controls button {
      background: rgba(255,255,255,0.1);
      border: 2px solid #e67e22;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      font-size: 1.2em;
      padding: 20px 40px;
      margin: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    .controls button:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 45px rgba(230,126,34,0.5);
    }
    .controls button:before {
      content: "";
      position: absolute;
      top: 0;
      left: -75%;
      width: 50%;
      height: 100%;
      background: rgba(255,255,255,0.2);
      transform: skewX(-25deg);
      transition: all 0.5s ease;
    }
    .controls button:hover:before {
      left: 125%;
    }

    /* Inline-Fragencontainer mit Glassmorphism */
    .question-display {
      background: rgba(52,73,94, 0.5);
      padding: 30px;
      border-radius: 10px;
      margin: 30px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    /* √úberschriften im Fragebereich ‚Äì hervorgehoben mit Unterstrich */
    .question-display h3 {
      position: relative;
      margin-bottom: 10px;
      font-size: 1.6em;
    }
    .question-display h3:after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 50px;
      height: 3px;
      background: #e67e22;
    }

    .explanation {
      margin-top: 20px;
      padding: 15px;
      background: rgba(44, 62, 80, 0.7);
      border-radius: 8px;
      white-space: pre-wrap;
      line-height: 1.6;
    }

    .timer {
      font-size: 24px;
      color: #e74c3c;
      margin: 15px 0;
    }

    .timer-controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }
  </style>
</head>
<body>
  <h1>Quiz</h1>

  <!-- Excel-Import UI ‚Äì ausschlie√ülich sichtbar, bis ein Report hochgeladen wurde -->
  <input type="file" id="excelUpload" accept=".xlsx" hidden>
  <button onclick="handleExcelUpload()">Excel Import üóÇÔ∏è</button>

  <!-- Spielsteuerung: erst nach Excel-Import werden hier Inhalte gef√ºllt -->
  <div class="controls" id="controls" style="display: none;">
    <button onclick="startGame(1)">1 Team</button>
    <button onclick="startGame(2)">2 Teams</button>
    <button onclick="startGame(3)">3 Teams</button>
  </div>

  <div class="teams" id="teamsContainer"></div>

  <div class="grid" id="questionsGrid">
    <p style="text-align:center; color:#ccc;">Noch keine Fragen importiert. Bitte laden Sie einen Excel Report hoch.</p>
  </div>

  <!-- Nicht genutzt ‚Äì Fragen werden inline angezeigt -->
  <div class="question-display" id="questionDisplay" style="display:none">
    W√§hlen Sie eine Frage aus der Quiz-Wand!
  </div>

  <script>
    /*******************************
     * Excel-Import Modul
     *******************************/
    async function handleExcelUpload() {
      const fileInput = document.getElementById("excelUpload");
      fileInput.click();
      fileInput.onchange = async (e) => {
        try {
          const file = e.target.files[0];
          if (!file) return;
          const data = await file.arrayBuffer();
          const workbook = XLSX.read(data, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          // Array of Arrays; leere Zellen als "" zur√ºckgegeben
          const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });

          // Initialisiere leeres Import-Objekt
          const importedQuestions = { easy: [], medium: [], hard: [], death: [] };
          const categories = ["easy", "medium", "hard", "death"];
          const headerRegex = /(easy|medium|hard|death)\s*\d+/i;

          // F√ºr jede Kategorie-Spalte (A=0, B=1, etc.)
          for (let colIndex = 0; colIndex < categories.length; colIndex++) {
            // Durchlaufe alle Zeilen
            for (let row = 0; row < json.length; row++) {
              const cell = json[row][colIndex];
              if (typeof cell === "string" && cell.trim() && cell.match(headerRegex)) {
                // Frage und Erkl√§rung aus den n√§chsten beiden Zeilen
                const questionText = json[row + 1] ? json[row + 1][colIndex] : "";
                const explanationText = json[row + 2] ? json[row + 2][colIndex] : "";
                if (!questionText.trim() || !explanationText.trim()) {
                  showToast(`Fehler: Fehlende Frage oder Erkl√§rung bei "${cell}"`);
                  continue;
                }
                // Punkte je Kategorie
                let points;
                switch (categories[colIndex]) {
                  case "easy": points = 200; break;
                  case "medium": points = 400; break;
                  case "hard": points = 600; break;
                  case "death": points = 1000; break;
                  default: points = 0;
                }
                const newQuestion = {
                  question: questionText,
                  explanation: explanationText,
                  points: points,
                  used: false,
                  selected: false,
                  attempts: 0,
                  special: (categories[colIndex] === "death")
                };
                importedQuestions[categories[colIndex]].push(newQuestion);
                // √úberspringe den Block (Header, Frage, Erkl√§rung, Leerzeile)
                row += 3;
              }
            }
          }

          // Ersetze den globalen Fragenpool mit den importierten Fragen
          questions.easy = importedQuestions.easy;
          questions.medium = importedQuestions.medium;
          questions.hard = importedQuestions.hard;
          questions.death = importedQuestions.death;
          
          createQuestionGrid();
          // Nach Import: Zeige die Spielsteuerung (Team-Auswahl) an
          document.getElementById("controls").style.display = "flex";
          showToast("Excel Import erfolgreich!");
        } catch (err) {
          console.error(err);
          showToast("Fehler beim Importieren der Excel-Datei.");
        }
      };
    }

    function showToast(message) {
      const toast = document.createElement("div");
      toast.textContent = message;
      toast.style.position = "fixed";
      toast.style.bottom = "20px";
      toast.style.left = "50%";
      toast.style.transform = "translateX(-50%)";
      toast.style.background = "rgba(0,0,0,0.7)";
      toast.style.color = "#ecf0f1";
      toast.style.padding = "10px 20px";
      toast.style.borderRadius = "5px";
      toast.style.zIndex = "1000";
      document.body.appendChild(toast);
      setTimeout(() => { toast.remove(); }, 3000);
    }

    /*******************************
     * Quiz-Logik
     *******************************/
    // Globaler Fragenpool ‚Äì zun√§chst leer, bis ein Excel-Report importiert wurde
    const questions = {
      easy: [],
      medium: [],
      hard: [],
      death: []
    };

    let teams = [];
    let currentTeam = 0;
    let selectedQuestion = null;
    let countdownInterval = null;
    let timeLeft = 0;
    let timerRunning = false;
    // Referenz auf das aktuell ge√∂ffnete Karten-DOM-Element
    let openInlineQuestionCard = null;

    function startGame(teamCount) {
      teams = Array.from({ length: teamCount }, (_, i) => ({
        name: `Team ${i + 1}`,
        points: 0
      }));
      
      Object.values(questions).forEach(category => {
        category.forEach(q => {
          q.used = false;
          q.selected = false;
          q.attempts = 0;
        });
      });

      currentTeam = 0;
      clearInterval(countdownInterval);
      timerRunning = false;
      renderTeams();
      createQuestionGrid();
    }

    function renderTeams() {
      const container = document.getElementById("teamsContainer");
      container.innerHTML = teams.map((team, index) => `
        <div class="team ${index === currentTeam ? 'active' : ''}">
          <h3>${team.name}</h3>
          <div class="points">${team.points} Punkte</div>
        </div>
      `).join('');
    }

    function createQuestionGrid() {
      const grid = document.getElementById("questionsGrid");
      grid.innerHTML = "";
      
      let hasQuestions = false;
      Object.entries(questions).forEach(([difficulty, items]) => {
        if (items.length) hasQuestions = true;
        items.forEach((q, index) => {
          const card = document.createElement("div");
          card.className = `question-card ${difficulty} ${q.used ? 'used' : ''} ${q.selected ? 'selected' : ''}`;
          card.innerHTML = `
            <div class="points-badge">${q.attempts > 0 ? Math.floor(q.points / 2) : q.points}</div>
            ${q.special ? 'üíÄ' : ''} ${difficulty.toUpperCase()}<br>
            Frage ${index + 1}
          `;
          
          if (!q.used) {
            card.onclick = () => {
              toggleInlineQuestion(card, q, difficulty, index);
            };
          }
          grid.appendChild(card);
        });
      });
      if (!hasQuestions) {
        grid.innerHTML = `<p style="text-align:center; color:#ccc;">Noch keine Fragen importiert. Bitte laden Sie einen Excel Report hoch.</p>`;
      }
    }

    function toggleInlineQuestion(card, question, difficulty, index) {
      // Falls dieselbe Karte bereits ausgew√§hlt war: Schlie√üe sie
      if (openInlineQuestionCard === card) {
        closeInlineQuestion();
        question.selected = false;
        return;
      }
      
      // Falls bereits eine andere Karte ge√∂ffnet ist, schlie√üe diese
      if (openInlineQuestionCard && openInlineQuestionCard !== card) {
        closeInlineQuestion();
      }
      
      // Markiere die aktuelle Frage als ausgew√§hlt
      selectedQuestion = question;
      question.selected = true;
      card.classList.add("selected");
      openInlineQuestionCard = card;
      
      let seconds = 60;
      if (difficulty === 'medium') seconds = 120;
      if (difficulty === 'hard') seconds = 180;
      if (difficulty === 'death') seconds = 75;
      timeLeft = seconds;
      timerRunning = false;
      
      const inlineContainer = document.createElement("div");
      inlineContainer.id = "inlineQuestionDisplay";
      inlineContainer.className = "question-display";
      inlineContainer.style.gridColumn = "1 / -1";
      
      // √úberschrift: Kategorie, Frage-Nummer und Punkte
      let displayHTML = `
        <h3>${difficulty.toUpperCase()}-Frage ${index + 1} (${question.attempts > 0 ? Math.floor(question.points / 2) : question.points} Punkte)</h3>
        <p>${question.question}</p>
        <div class="timer" id="timerDisplay">Timer: ${formatTime(seconds)}</div>
        <div class="timer-controls">
          <button id="timerControl" onclick="toggleTimer()">Timer starten</button>
          <button onclick="resetTimer()">Timer zur√ºcksetzen</button>
        </div>
      `;
      
      if (question.joker) {
        displayHTML += `
          <button onclick="handleJoker()">Joker einsetzen üéâ</button>
          <div class="explanation" id="explanation" style="display:none">
            ${question.explanation}
          </div>
        `;
      } else if (difficulty === 'death') {
        displayHTML += `
          <div class="explanation">
            ${question.explanation}
          </div>
          <div id="specialTaskButtons" style="margin-top:20px">
            <button onclick="handleSpecialSuccess()">Aufgabe geschafft ‚úÖ</button>
            <button onclick="handleAnswer(false)">Zeit abgelaufen ‚ùå</button>
          </div>
        `;
      } else {
        displayHTML += `
          <button onclick="revealAnswer()">Antwort anzeigen</button>
          <div class="explanation" id="explanation" style="display:none">
            ${question.explanation}
          </div>
          <div id="judgementButtons" style="display:none; margin-top:20px">
            <button onclick="handleAnswer(true)">Richtig ‚úÖ</button>
            <button onclick="handleAnswer(false)">Falsch ‚ùå</button>
          </div>
        `;
      }
      
      inlineContainer.innerHTML = displayHTML;
      card.parentNode.insertBefore(inlineContainer, card.nextSibling);
    }

    function resetTimer() {
      const difficulty = Object.entries(questions).find(([_, cat]) => 
        cat.includes(selectedQuestion)
      )[0];
      
      if (difficulty === 'easy') timeLeft = 60;
      else if (difficulty === 'medium') timeLeft = 120;
      else if (difficulty === 'hard') timeLeft = 180;
      else timeLeft = 75;
      
      updateTimerDisplay();
    }

    function toggleTimer() {
      const timerButton = document.getElementById('timerControl');
      if (!timerRunning) {
        timerRunning = true;
        timerButton.textContent = 'Timer stoppen';
        startTimer(timeLeft);
      } else {
        timerRunning = false;
        timerButton.textContent = 'Timer fortsetzen';
        clearInterval(countdownInterval);
      }
    }

    function startTimer(seconds) {
      timeLeft = seconds;
      updateTimerDisplay();
      
      countdownInterval = setInterval(() => {
        if (timerRunning) {
          timeLeft--;
          updateTimerDisplay();
          
          if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            if (selectedQuestion && !selectedQuestion.joker) {
              handleAnswer(false);
            }
          }
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const timerDisplay = document.getElementById('timerDisplay');
      if (timerDisplay) {
        timerDisplay.textContent = `Timer: ${formatTime(timeLeft)}`;
      }
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function revealAnswer() {
      document.getElementById('explanation').style.display = 'block';
      document.getElementById('judgementButtons').style.display = 'block';
    }

    function handleJoker() {
      teams[currentTeam].points += selectedQuestion.points;
      selectedQuestion.used = true;
      clearInterval(countdownInterval);
      closeInlineQuestion();
      nextRound();
    }

    function handleSpecialSuccess() {
      teams[currentTeam].points += selectedQuestion.points;
      selectedQuestion.used = true;
      clearInterval(countdownInterval);
      closeInlineQuestion();
      nextRound();
    }

    function handleAnswer(isCorrect) {
      clearInterval(countdownInterval);
      timerRunning = false;
      
      if (isCorrect) {
        const points = selectedQuestion.attempts > 0 
          ? Math.floor(selectedQuestion.points / 2)
          : selectedQuestion.points;
        
        teams[currentTeam].points += points;
        selectedQuestion.used = true;
      } else {
        selectedQuestion.attempts++;
        if (selectedQuestion.attempts >= 2) {
          selectedQuestion.used = true;
        }
      }
      selectedQuestion.selected = false;
      closeInlineQuestion();
      currentTeam = (currentTeam + 1) % teams.length;
      
      renderTeams();
      createQuestionGrid();
      
      document.getElementById("questionDisplay").innerHTML = `
        <p>${isCorrect ? '‚úÖ Richtige Antwort!' : '‚ùå Falsche Antwort oder Zeit abgelaufen!'}<br>
        N√§chste Runde: ${teams[currentTeam].name}</p>
      `;
      
      checkGameEnd();
    }

    // Entfernt den Inline-Fragencontainer und entfernt die "selected"-Klasse von der ge√∂ffneten Karte
    function closeInlineQuestion() {
      const inline = document.getElementById("inlineQuestionDisplay");
      if (inline) inline.remove();
      if (openInlineQuestionCard) {
        openInlineQuestionCard.classList.remove("selected");
      }
      openInlineQuestionCard = null;
    }

    function nextRound() {
      selectedQuestion.selected = false;
      closeInlineQuestion();
      currentTeam = (currentTeam + 1) % teams.length;
      renderTeams();
      createQuestionGrid();
      document.getElementById("questionDisplay").innerHTML = `
        <p>N√§chste Runde: ${teams[currentTeam].name}</p>
      `;
      checkGameEnd();
    }

    function checkGameEnd() {
      const allUsed = Object.values(questions).every(category => 
        category.every(q => q.used)
      );
      
      if (allUsed) {
        const winner = teams.reduce((prev, current) => 
          (prev.points > current.points) ? prev : current);
          
        alert(`üèÜ Spielende! Gewinner ist ${winner.name} mit ${winner.points} Punkten!`);
        startGame(teams.length);
      }
    }
  </script>
</body>
</html>
